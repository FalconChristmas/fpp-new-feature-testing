#!/usr/bin/env python3
"""
FPP AES67 SAP Announcer — sends AES67-compliant SAP/SDP announcements.

Replaces PipeWire's built-in SAP which generates non-compliant SDP
(missing ts-refclk, wrong mediaclk, wrong direction attribute).

Sends SAP announcements for each enabled AES67 send instance per RFC 2974,
with SDP per AES67 / RAVENNA requirements:
  - a=ts-refclk:ptp=IEEE1588-2008:<gmClockId>:0
  - a=mediaclk:direct=0
  - a=sendonly
  - a=rtpmap:96 L24/48000/<channels>

Usage: fpp_aes67_sap [--once] [--interval SECONDS]
"""

import json
import hashlib
import socket
import struct
import sys
import time
import os
import signal
import argparse
import subprocess
import re

SAP_MCAST = "224.2.127.254"
SAP_PORT = 9875
SAP_VERSION = 1  # SAPv2 (version field = 1 in the header)
ANNOUNCE_INTERVAL = 30  # seconds between announcements
CONFIG_PATH = "/home/fpp/media/config/pipewire-aes67-instances.json"

running = True


def signal_handler(sig, frame):
    global running
    running = False


def get_ptp_clock_id(interface="eth0"):
    """
    Derive PTP clock identity from the interface MAC address.
    EUI-64: insert FF:FE in the middle of the MAC, format as
    XX-XX-XX-FF-FE-XX-XX-XX for AES67 ts-refclk.
    """
    try:
        mac = open(f"/sys/class/net/{interface}/address").read().strip()
    except Exception:
        return None

    parts = mac.split(":")
    if len(parts) != 6:
        return None

    # EUI-64: insert FF:FE between bytes 3 and 4
    eui64 = parts[0:3] + ["FF", "FE"] + parts[3:6]
    return "-".join(p.upper() for p in eui64)


def get_ptp_gm_clock_id(interface="eth0"):
    """
    Try to get the actual grandmaster clock ID from ptp4l log.
    Falls back to local EUI-64 if we are the grandmaster or can't determine.
    """
    local_eui64 = get_ptp_clock_id(interface)

    try:
        log = open("/var/log/ptp4l-fpp.log").read()
        # Look for "selected local clock XXXXXX.fffe.XXXXXX as best master"
        # or "new foreign master XXXXXX.fffe.XXXXXX"
        m = re.search(r"selected.*clock\s+([0-9a-f.]+)\s+as best master", log)
        if m:
            raw = m.group(1).replace(".", "")  # e.g. d83addfffea6eb03
            # Format as XX-XX-XX-XX-XX-XX-XX-XX
            gm = "-".join(raw[i:i+2].upper() for i in range(0, 16, 2))
            return gm
    except Exception:
        pass

    return local_eui64


def get_source_ip(interface="eth0"):
    """Get the IP address of the specified interface."""
    try:
        output = subprocess.check_output(
            ["ip", "-4", "addr", "show", interface],
            text=True
        )
        m = re.search(r"inet (\d+\.\d+\.\d+\.\d+)", output)
        if m:
            return m.group(1)
    except Exception:
        pass
    return "0.0.0.0"


def build_sdp(instance, source_ip, ptp_clock_id):
    """Build an AES67-compliant SDP for a send instance."""
    session_id = str(abs(hash(instance["name"])) % 2**31)
    channels = instance.get("channels", 2)
    multicast_ip = instance.get("multicastIP", "239.69.0.1")
    port = instance.get("port", 5004)
    session_name = instance.get("sessionName", instance.get("name", "FPP AES67"))
    ptime = str(instance.get("ptime", 4))  # packet time in ms — must match PipeWire config

    # Channel positions for SDP
    if channels == 1:
        ch_names = "M"
    elif channels == 2:
        ch_names = "FL, FR"
    elif channels == 4:
        ch_names = "FL, FR, RL, RR"
    elif channels == 6:
        ch_names = "FL, FR, FC, LFE, RL, RR"
    elif channels == 8:
        ch_names = "FL, FR, FC, LFE, RL, RR, SL, SR"
    else:
        ch_names = ", ".join(f"AUX{i+1}" for i in range(channels))

    ttl = 32

    sdp = (
        f"v=0\r\n"
        f"o=- {session_id} {session_id} IN IP4 {source_ip}\r\n"
        f"s={session_name}\r\n"
        f"c=IN IP4 {multicast_ip}/{ttl}\r\n"
        f"t=0 0\r\n"
        f"m=audio {port} RTP/AVP 96\r\n"
        f"i={channels} channels: {ch_names}\r\n"
        f"a=rtpmap:96 L24/48000/{channels}\r\n"
        f"a=sendonly\r\n"
        f"a=ptime:{ptime}\r\n"
        f"a=ts-refclk:ptp=IEEE1588-2008:{ptp_clock_id}:0\r\n"
        f"a=mediaclk:direct=0\r\n"
        f"a=source-filter: incl IN IP4 {multicast_ip} {source_ip}\r\n"
    )

    return sdp


def build_sap_packet(source_ip, sdp, msg_id_hash, announce=True):
    """
    Build a SAP packet per RFC 2974.
    Header: V=1, A=0/1, R=0, T=0, L=0, msg_id_hash, originating_source
    Payload: "application/sdp\0" + SDP
    """
    # Flags byte: version(3 bits)=1, A(1 bit), R(1 bit), T(1 bit), E(1 bit), C(1 bit)
    # V=1 (001), A=0 for announce / 1 for delete, R=0, T=0, E=0, C=0
    version_flags = (SAP_VERSION << 5)
    if not announce:
        version_flags |= 0x04  # A bit = deletion

    auth_len = 0  # no authentication

    # Source IP as 4 bytes
    src_bytes = socket.inet_aton(source_ip)

    header = struct.pack("!BBH4s",
                         version_flags,
                         auth_len,
                         msg_id_hash & 0xFFFF,
                         src_bytes)

    payload_type = b"application/sdp\x00"
    return header + payload_type + sdp.encode("utf-8")


def load_config():
    """Load AES67 instance configuration."""
    try:
        with open(CONFIG_PATH, "r") as f:
            data = json.load(f)
        return data
    except Exception as e:
        print(f"Error loading config: {e}", file=sys.stderr)
        return None


def send_announcements(sock, config, source_ip, ptp_clock_id, announce=True):
    """Send SAP announcements for all enabled send instances."""
    if not config or "instances" not in config:
        return 0

    count = 0
    for inst in config["instances"]:
        if not inst.get("enabled", False):
            continue
        if inst.get("mode", "send") != "send":
            continue
        if not inst.get("sapEnabled", True):
            continue

        sdp = build_sdp(inst, source_ip, ptp_clock_id)

        # Stable hash for this instance (used as SAP msg_id_hash)
        id_str = f"{inst.get('multicastIP', '')}:{inst.get('port', 5004)}:{inst.get('name', '')}"
        msg_id_hash = int(hashlib.md5(id_str.encode()).hexdigest()[:4], 16)

        packet = build_sap_packet(source_ip, sdp, msg_id_hash, announce=announce)

        try:
            sock.sendto(packet, (SAP_MCAST, SAP_PORT))
            count += 1
            action = "Announced" if announce else "Deleted"
            if "--once" in sys.argv or not announce:
                print(f"{action}: {inst['name']} -> {inst.get('multicastIP')}:{inst.get('port')}")
        except Exception as e:
            print(f"Error sending SAP for {inst.get('name', '?')}: {e}", file=sys.stderr)

    return count


def main():
    parser = argparse.ArgumentParser(description="FPP AES67 SAP Announcer")
    parser.add_argument("--once", action="store_true", help="Send one round then exit")
    parser.add_argument("--delete", action="store_true", help="Send deletion then exit")
    parser.add_argument("--interval", type=int, default=ANNOUNCE_INTERVAL, help="Seconds between announcements")
    parser.add_argument("--interface", default="eth0", help="Network interface")
    args = parser.parse_args()

    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    config = load_config()
    if not config:
        print("No AES67 config found, exiting.", file=sys.stderr)
        sys.exit(1)

    interface = config.get("ptpInterface", args.interface)
    source_ip = get_source_ip(interface)
    ptp_clock_id = get_ptp_gm_clock_id(interface)

    if not ptp_clock_id:
        print(f"Could not determine PTP clock ID for {interface}", file=sys.stderr)
        sys.exit(1)

    print(f"FPP AES67 SAP Announcer starting", file=sys.stderr)
    print(f"  Interface: {interface} ({source_ip})", file=sys.stderr)
    print(f"  PTP Clock: {ptp_clock_id}", file=sys.stderr)
    print(f"  Interval:  {args.interval}s", file=sys.stderr)

    # Create UDP socket for SAP multicast
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, 4)

    # Bind to source interface
    try:
        sock.setsockopt(
            socket.IPPROTO_IP,
            socket.IP_MULTICAST_IF,
            socket.inet_aton(source_ip)
        )
    except Exception as e:
        print(f"Warning: could not bind multicast to {source_ip}: {e}", file=sys.stderr)

    if args.delete:
        send_announcements(sock, config, source_ip, ptp_clock_id, announce=False)
        sock.close()
        return

    if args.once:
        count = send_announcements(sock, config, source_ip, ptp_clock_id)
        print(f"Sent {count} SAP announcements", file=sys.stderr)
        sock.close()
        return

    # Continuous announcement loop
    while running:
        # Reload config each cycle in case it changed
        config = load_config()
        ptp_clock_id = get_ptp_gm_clock_id(interface)

        count = send_announcements(sock, config, source_ip, ptp_clock_id)

        # Sleep in small increments so we can respond to SIGTERM
        for _ in range(args.interval * 10):
            if not running:
                break
            time.sleep(0.1)

    # Send deletion announcements on shutdown
    print("Shutting down, sending SAP deletions...", file=sys.stderr)
    send_announcements(sock, config, source_ip, ptp_clock_id, announce=False)
    sock.close()


if __name__ == "__main__":
    main()
