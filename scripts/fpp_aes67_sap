#!/usr/bin/env python3
"""
FPP AES67 SAP Announcer â€” sends AES67-compliant SAP/SDP announcements.

Replaces PipeWire's built-in SAP which generates non-compliant SDP
(missing ts-refclk, wrong mediaclk, wrong direction attribute).

Sends SAP announcements for each enabled AES67 send instance per RFC 2974,
with SDP per AES67 / RAVENNA requirements:
  - a=ts-refclk:ptp=IEEE1588-2008:<gmClockId>:0
  - a=mediaclk:direct=0
  - a=sendonly
  - a=rtpmap:96 L24/48000/<channels>

Usage: fpp_aes67_sap [--once] [--interval SECONDS]
"""

import hashlib
import socket
import struct
import sys
import time
import os
import signal
import argparse
import subprocess
import re

# Import shared constants from common module
sys.path.insert(0, os.path.dirname(os.path.abspath(__file__)))
from fpp_aes67_common import (
    SAP_MCAST_ADDRESS,
    SAP_PORT,
    SAP_VERSION,
    SAP_ANNOUNCE_INTERVAL,
    SAP_TTL,
    CONFIG_JSON_PATH,
    PTP_LOG_PATH,
    load_config,
    build_sdp,
)

running = True


def signal_handler(sig, frame):
    global running
    running = False


def get_ptp_clock_id(interface="eth0"):
    """
    Derive PTP clock identity from the interface MAC address.
    EUI-64: insert FF:FE in the middle of the MAC, format as
    XX-XX-XX-FF-FE-XX-XX-XX for AES67 ts-refclk.
    """
    try:
        mac = open(f"/sys/class/net/{interface}/address").read().strip()
    except Exception:
        return None

    parts = mac.split(":")
    if len(parts) != 6:
        return None

    # EUI-64: insert FF:FE between bytes 3 and 4
    eui64 = parts[0:3] + ["FF", "FE"] + parts[3:6]
    return "-".join(p.upper() for p in eui64)


def get_ptp_gm_clock_id(interface="eth0"):
    """
    Try to get the actual grandmaster clock ID from ptp4l log.
    Falls back to local EUI-64 if we are the grandmaster or can't determine.
    """
    local_eui64 = get_ptp_clock_id(interface)

    try:
        log = open(PTP_LOG_PATH).read()
        m = re.search(r"selected.*clock\s+([0-9a-f.]+)\s+as best master", log)
        if m:
            raw = m.group(1).replace(".", "")
            gm = "-".join(raw[i:i+2].upper() for i in range(0, 16, 2))
            return gm
    except Exception:
        pass

    return local_eui64


def get_source_ip(interface="eth0"):
    """Get the IP address of the specified interface."""
    try:
        output = subprocess.check_output(
            ["ip", "-4", "addr", "show", interface],
            text=True
        )
        m = re.search(r"inet (\d+\.\d+\.\d+\.\d+)", output)
        if m:
            return m.group(1)
    except Exception:
        pass
    return "0.0.0.0"


def build_sap_packet(source_ip, sdp, msg_id_hash, announce=True):
    """
    Build a SAP packet per RFC 2974.
    Header: V=1, A=0/1, R=0, T=0, L=0, msg_id_hash, originating_source
    Payload: "application/sdp\0" + SDP
    """
    # Flags byte: version(3 bits)=1, A(1 bit), R(1 bit), T(1 bit), E(1 bit), C(1 bit)
    # V=1 (001), A=0 for announce / 1 for delete, R=0, T=0, E=0, C=0
    version_flags = (SAP_VERSION << 5)
    if not announce:
        version_flags |= 0x04  # A bit = deletion

    auth_len = 0  # no authentication

    # Source IP as 4 bytes
    src_bytes = socket.inet_aton(source_ip)

    header = struct.pack("!BBH4s",
                         version_flags,
                         auth_len,
                         msg_id_hash & 0xFFFF,
                         src_bytes)

    payload_type = b"application/sdp\x00"
    return header + payload_type + sdp.encode("utf-8")


def send_announcements(sock, config, source_ip, ptp_clock_id, announce=True):
    """Send SAP announcements for all enabled send instances."""
    if not config or "instances" not in config:
        return 0

    count = 0
    for inst in config["instances"]:
        if not inst.get("enabled", False):
            continue
        if inst.get("mode", "send") != "send":
            continue
        if not inst.get("sapEnabled", True):
            continue

        sdp = build_sdp(inst, source_ip, ptp_clock_id)

        # Stable hash for this instance (used as SAP msg_id_hash)
        id_str = f"{inst.get('multicastIP', '')}:{inst.get('port', 5004)}:{inst.get('name', '')}"
        msg_id_hash = int(hashlib.md5(id_str.encode()).hexdigest()[:4], 16)

        packet = build_sap_packet(source_ip, sdp, msg_id_hash, announce=announce)

        try:
            sock.sendto(packet, (SAP_MCAST_ADDRESS, SAP_PORT))
            count += 1
            action = "Announced" if announce else "Deleted"
            if "--once" in sys.argv or not announce:
                print(f"{action}: {inst['name']} -> {inst.get('multicastIP')}:{inst.get('port')}")
        except Exception as e:
            print(f"Error sending SAP for {inst.get('name', '?')}: {e}", file=sys.stderr)

    return count


def main():
    parser = argparse.ArgumentParser(description="FPP AES67 SAP Announcer")
    parser.add_argument("--once", action="store_true", help="Send one round then exit")
    parser.add_argument("--delete", action="store_true", help="Send deletion then exit")
    parser.add_argument("--interval", type=int, default=SAP_ANNOUNCE_INTERVAL, help="Seconds between announcements")
    parser.add_argument("--interface", default="eth0", help="Network interface")
    args = parser.parse_args()

    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    config = load_config()
    if not config:
        print("No AES67 config found, exiting.", file=sys.stderr)
        sys.exit(1)

    interface = config.get("ptpInterface", args.interface)
    source_ip = get_source_ip(interface)
    ptp_clock_id = get_ptp_gm_clock_id(interface)

    if not ptp_clock_id:
        print(f"Could not determine PTP clock ID for {interface}", file=sys.stderr)
        sys.exit(1)

    print(f"FPP AES67 SAP Announcer starting", file=sys.stderr)
    print(f"  Interface: {interface} ({source_ip})", file=sys.stderr)
    print(f"  PTP Clock: {ptp_clock_id}", file=sys.stderr)
    print(f"  Interval:  {args.interval}s", file=sys.stderr)

    # Create UDP socket for SAP multicast
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
    sock.setsockopt(socket.IPPROTO_IP, socket.IP_MULTICAST_TTL, SAP_TTL)

    # Bind to source interface
    try:
        sock.setsockopt(
            socket.IPPROTO_IP,
            socket.IP_MULTICAST_IF,
            socket.inet_aton(source_ip)
        )
    except Exception as e:
        print(f"Warning: could not bind multicast to {source_ip}: {e}", file=sys.stderr)

    if args.delete:
        send_announcements(sock, config, source_ip, ptp_clock_id, announce=False)
        sock.close()
        return

    if args.once:
        count = send_announcements(sock, config, source_ip, ptp_clock_id)
        print(f"Sent {count} SAP announcements", file=sys.stderr)
        sock.close()
        return

    # Continuous announcement loop
    while running:
        # Reload config each cycle in case it changed
        config = load_config()
        ptp_clock_id = get_ptp_gm_clock_id(interface)

        count = send_announcements(sock, config, source_ip, ptp_clock_id)

        # Sleep in small increments so we can respond to SIGTERM
        for _ in range(args.interval * 10):
            if not running:
                break
            time.sleep(0.1)

    # Send deletion announcements on shutdown
    print("Shutting down, sending SAP deletions...", file=sys.stderr)
    send_announcements(sock, config, source_ip, ptp_clock_id, announce=False)
    sock.close()


if __name__ == "__main__":
    main()
