#!/bin/bash
# AES67 GStreamer Subsystem Test Script
# Part of Falcon Player (FPP) Phase 7.10
#
# Usage:
#   ./aes67_test              Run all tests
#   ./aes67_test --self-test  Run fppd self-test via command API
#   ./aes67_test --status     Query AES67 status from fppd
#   ./aes67_test --send       Test send pipeline locally
#   ./aes67_test --receive    Test receive pipeline locally
#   ./aes67_test --sap        Monitor SAP announcements
#   ./aes67_test --ptp        Test PTP clock elements
#   ./aes67_test --elements   Verify required GStreamer elements

set -euo pipefail

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

PASS=0
FAIL=0
WARN=0

pass() {
    echo -e "${GREEN}PASS${NC}: $1"
    PASS=$((PASS + 1))
}

fail() {
    echo -e "${RED}FAIL${NC}: $1"
    FAIL=$((FAIL + 1))
}

warn() {
    echo -e "${YELLOW}WARN${NC}: $1"
    WARN=$((WARN + 1))
}

summary() {
    echo ""
    echo "============================="
    echo -e "Results: ${GREEN}${PASS} passed${NC}, ${RED}${FAIL} failed${NC}, ${YELLOW}${WARN} warnings${NC}"
    echo "============================="
    if [ $FAIL -gt 0 ]; then
        exit 1
    fi
}

# ─────────────────────────────────────────────────────────────────────
# Test: GStreamer elements available
# ─────────────────────────────────────────────────────────────────────
test_elements() {
    echo ""
    echo "=== GStreamer Element Availability ==="
    local elements="rtpL24pay rtpL24depay rtpjitterbuffer rtpbin udpsrc udpsink audioconvert audioresample pipewiresrc pipewiresink"
    for elem in $elements; do
        if gst-inspect-1.0 "$elem" >/dev/null 2>&1; then
            pass "$elem element available"
        else
            fail "$elem element NOT FOUND"
        fi
    done
}

# ─────────────────────────────────────────────────────────────────────
# Test: PTP clock support
# ─────────────────────────────────────────────────────────────────────
test_ptp() {
    echo ""
    echo "=== PTP Clock Support ==="

    # Check gst-ptp-helper exists
    local ptp_helper
    ptp_helper=$(find /usr/lib -name "gst-ptp-helper*" 2>/dev/null | head -1)
    if [ -n "$ptp_helper" ]; then
        pass "gst-ptp-helper found: $ptp_helper"
        # Check capabilities
        if getcap "$ptp_helper" 2>/dev/null | grep -q "cap_net_bind_service\|cap_net_admin\|cap_net_raw"; then
            pass "gst-ptp-helper has network capabilities"
        elif [ -u "$ptp_helper" ]; then
            pass "gst-ptp-helper is setuid"
        else
            warn "gst-ptp-helper may lack network capabilities (needs CAP_NET_BIND_SERVICE or setuid)"
        fi
    else
        fail "gst-ptp-helper not found"
    fi

    # Check if GstPtpClock is available in gstreamer-net
    if pkg-config --exists gstreamer-net-1.0 2>/dev/null; then
        pass "gstreamer-net-1.0 package available"
    else
        fail "gstreamer-net-1.0 package NOT available"
    fi
}

# ─────────────────────────────────────────────────────────────────────
# Test: Local send pipeline (sends 2 seconds of silence to loopback)
# ─────────────────────────────────────────────────────────────────────
test_send() {
    echo ""
    echo "=== Send Pipeline Test ==="

    # Create a test send pipeline with audiotestsrc instead of pipewiresrc
    # This verifies the RTP payload and UDP multicast path work
    local test_ip="239.69.99.99"
    local test_port="15004"

    echo "Testing: audiotestsrc ! audioconvert ! S24BE,48kHz,2ch ! rtpL24pay ! udpsink"
    echo "Multicast: $test_ip:$test_port (2 seconds)"

    timeout 3 gst-launch-1.0 -q \
        audiotestsrc wave=silence num-buffers=96 \
        ! audioconvert \
        ! "audio/x-raw,format=S24BE,rate=48000,channels=2" \
        ! rtpL24pay pt=96 min-ptime=4000000 max-ptime=4000000 \
        ! udpsink host="$test_ip" port="$test_port" ttl=1 auto-multicast=true sync=false \
        2>&1 && pass "Send pipeline executed successfully" || fail "Send pipeline failed"
}

# ─────────────────────────────────────────────────────────────────────
# Test: Local receive pipeline (listens for 2 seconds)
# ─────────────────────────────────────────────────────────────────────
test_receive() {
    echo ""
    echo "=== Receive Pipeline Test ==="

    local test_ip="239.69.99.99"
    local test_port="15004"

    echo "Testing: udpsrc ! rtpjitterbuffer ! rtpL24depay ! audioconvert ! fakesink"
    echo "Listening on: $test_ip:$test_port (3 seconds)"

    # First start a sender in background
    gst-launch-1.0 -q \
        audiotestsrc wave=sine freq=1000 num-buffers=150 \
        ! audioconvert \
        ! "audio/x-raw,format=S24BE,rate=48000,channels=2" \
        ! rtpL24pay pt=96 min-ptime=4000000 max-ptime=4000000 \
        ! udpsink host="$test_ip" port="$test_port" ttl=1 auto-multicast=true sync=false \
        2>&1 &
    local sender_pid=$!

    sleep 0.5

    # Try to receive
    local received=0
    timeout 3 gst-launch-1.0 -q \
        udpsrc multicast-group="$test_ip" port="$test_port" auto-multicast=true \
        ! "application/x-rtp,media=audio,clock-rate=48000,encoding-name=L24,channels=2,payload=96" \
        ! rtpjitterbuffer latency=10 \
        ! rtpL24depay \
        ! audioconvert \
        ! fakesink sync=false \
        2>&1 && received=1

    kill $sender_pid 2>/dev/null || true
    wait $sender_pid 2>/dev/null || true

    if [ $received -eq 1 ]; then
        pass "Receive pipeline captured RTP audio"
    else
        # Receive timeout is expected if multicast routing isn't set up on loopback
        warn "Receive pipeline timed out (may need multicast routing for loopback test)"
    fi
}

# ─────────────────────────────────────────────────────────────────────
# Test: SAP announcement monitoring
# ─────────────────────────────────────────────────────────────────────
test_sap() {
    echo ""
    echo "=== SAP Announcement Monitor ==="
    echo "Listening for SAP announcements on 239.255.255.255:9875 (5 seconds)..."

    local found=0
    timeout 5 bash -c '
        python3 -c "
import socket, struct, sys
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
sock.bind((\"\", 9875))
mreq = struct.pack(\"4sl\", socket.inet_aton(\"239.255.255.255\"), socket.INADDR_ANY)
sock.setsockopt(socket.IPPROTO_IP, socket.IP_ADD_MEMBERSHIP, mreq)
sock.settimeout(5)
try:
    data, addr = sock.recvfrom(4096)
    print(f\"SAP packet from {addr[0]}:{addr[1]} ({len(data)} bytes)\")
    # Parse SAP header
    flags = data[0]
    version = (flags >> 5) & 0x7
    msg_type = \"deletion\" if (flags & 0x04) else \"announcement\"
    auth_len = data[1]
    hash_val = struct.unpack(\"!H\", data[2:4])[0]
    origin_ip = socket.inet_ntoa(data[4:8])
    payload_start = 8 + auth_len * 4
    # Skip content type
    ct_end = data.index(0, payload_start) + 1
    sdp = data[ct_end:].decode(\"utf-8\", errors=\"replace\")
    print(f\"  Version: {version}, Type: {msg_type}, Hash: {hash_val:#06x}\")
    print(f\"  Origin: {origin_ip}\")
    print(f\"  SDP ({len(sdp)} chars):\")
    for line in sdp.split(chr(13) + chr(10))[:10]:
        if line.strip():
            print(f\"    {line.strip()}\")
    sys.exit(0)
except socket.timeout:
    print(\"No SAP announcements heard\")
    sys.exit(1)
" 2>&1' && found=1

    if [ $found -eq 1 ]; then
        pass "SAP announcements detected on network"
    else
        warn "No SAP announcements detected (is AES67 configured and running?)"
    fi
}

# ─────────────────────────────────────────────────────────────────────
# Test: fppd self-test via command API
# ─────────────────────────────────────────────────────────────────────
test_fppd_selftest() {
    echo ""
    echo "=== fppd AES67 Self-Test ==="

    # Check if fppd is running
    if ! pgrep -x fppd >/dev/null 2>&1; then
        warn "fppd is not running — skipping self-test"
        return
    fi

    local response
    response=$(curl -s "http://localhost:32322/aes67/test" 2>/dev/null) || {
        fail "Could not connect to fppd HTTP API on port 32322"
        return
    }

    if echo "$response" | python3 -c "
import sys, json
data = json.load(sys.stdin)
for t in data.get('tests', []):
    status = 'PASS' if t['passed'] else 'FAIL'
    print(f'  {status}: {t[\"test\"]} - {t[\"message\"]}')
s = data.get('summary', {})
print(f'  Total: {s.get(\"total\",0)} | Passed: {s.get(\"passed\",0)} | Failed: {s.get(\"failed\",0)}')
sys.exit(0 if s.get('allPassed', False) else 1)
" 2>/dev/null; then
        pass "fppd AES67 self-test passed"
    else
        fail "fppd AES67 self-test had failures"
    fi
}

# ─────────────────────────────────────────────────────────────────────
# Test: AES67 status query
# ─────────────────────────────────────────────────────────────────────
test_status() {
    echo ""
    echo "=== AES67 Status ==="

    if ! pgrep -x fppd >/dev/null 2>&1; then
        warn "fppd is not running — skipping status check"
        return
    fi

    local response
    response=$(curl -s "http://localhost:32322/aes67/status" 2>/dev/null) || {
        fail "Could not connect to fppd HTTP API"
        return
    }

    echo "$response" | python3 -c "
import sys, json
data = json.load(sys.stdin)
print(f'  Active: {data.get(\"active\", False)}')

ptp = data.get('ptp', {})
print(f'  PTP synced: {ptp.get(\"synced\", False)}')
print(f'  PTP offset: {ptp.get(\"offsetNs\", 0)} ns')
print(f'  PTP grandmaster: {ptp.get(\"grandmasterId\", \"unknown\")}')

pipelines = data.get('pipelines', [])
print(f'  Pipelines: {len(pipelines)}')
for p in pipelines:
    status = 'running' if p.get('running') else 'stopped'
    print(f'    [{p.get(\"instanceId\")}] {p.get(\"name\",\"?\")} ({p.get(\"mode\",\"?\")}) - {status}')
    if p.get('error'):
        print(f'      Error: {p[\"error\"]}')

streams = data.get('discoveredStreams', [])
print(f'  Discovered streams: {len(streams)}')
for s in streams:
    print(f'    {s.get(\"sessionName\",\"?\")} from {s.get(\"originAddress\",\"?\")} -> {s.get(\"multicastIP\",\"?\")}:{s.get(\"port\",0)}')
" 2>/dev/null && pass "Status query successful" || fail "Status query failed"
}

# ─────────────────────────────────────────────────────────────────────
# Test: AES67 config file
# ─────────────────────────────────────────────────────────────────────
test_config() {
    echo ""
    echo "=== AES67 Configuration ==="

    local config="/home/fpp/media/config/pipewire-aes67-instances.json"
    if [ -f "$config" ]; then
        pass "Config file exists: $config"
        local count
        count=$(python3 -c "import json; d=json.load(open('$config')); print(len(d.get('instances',[])))" 2>/dev/null || echo "0")
        if [ "$count" -gt 0 ]; then
            pass "$count instance(s) configured"
        else
            warn "No instances configured in $config"
        fi
    else
        warn "Config file not found: $config (AES67 not configured)"
    fi
}

# ─────────────────────────────────────────────────────────────────────
# Test: Legacy cleanup verification
# ─────────────────────────────────────────────────────────────────────
test_legacy_cleanup() {
    echo ""
    echo "=== Legacy Cleanup Verification ==="

    # Check legacy files are gone
    local legacy_files="/etc/pipewire/pipewire.conf.d/96-fpp-aes67-rtp.conf /etc/pipewire/pipewire.conf.d/96-fpp-aes67-sap.conf /etc/ptp4l-fpp.conf"
    for f in $legacy_files; do
        if [ ! -f "$f" ]; then
            pass "Legacy file removed: $f"
        else
            warn "Legacy file still exists: $f"
        fi
    done

    # Check legacy daemons not running
    if ! pgrep -f "fpp_aes67_sap" >/dev/null 2>&1; then
        pass "Legacy fpp_aes67_sap daemon not running"
    else
        warn "Legacy fpp_aes67_sap daemon is still running"
    fi

    if ! pgrep -f "ptp4l.*ptp4l-fpp" >/dev/null 2>&1; then
        pass "Legacy ptp4l daemon not running"
    else
        warn "Legacy ptp4l daemon is still running (PID: $(pgrep -f 'ptp4l.*ptp4l-fpp'))"
    fi
}

# ─────────────────────────────────────────────────────────────────────
# Main
# ─────────────────────────────────────────────────────────────────────
case "${1:-all}" in
    --elements)
        test_elements
        ;;
    --ptp)
        test_ptp
        ;;
    --send)
        test_send
        ;;
    --receive)
        test_receive
        ;;
    --sap)
        test_sap
        ;;
    --self-test)
        test_fppd_selftest
        ;;
    --status)
        test_status
        ;;
    --config)
        test_config
        ;;
    --legacy)
        test_legacy_cleanup
        ;;
    all|"")
        echo "FPP AES67 GStreamer Test Suite (Phase 7.10)"
        echo "==========================================="
        test_config
        test_elements
        test_ptp
        test_legacy_cleanup
        test_send
        test_receive
        test_fppd_selftest
        test_status
        test_sap
        ;;
    --help|-h)
        echo "Usage: $0 [--elements|--ptp|--send|--receive|--sap|--self-test|--status|--config|--legacy|--help]"
        echo ""
        echo "  (no args)    Run all tests"
        echo "  --elements   Verify required GStreamer elements"
        echo "  --ptp        Test PTP clock support"
        echo "  --send       Test send pipeline with audiotestsrc"
        echo "  --receive    Test send+receive loopback"
        echo "  --sap        Monitor SAP announcements (5 seconds)"
        echo "  --self-test  Run fppd self-test via HTTP API"
        echo "  --status     Query AES67 status from fppd"
        echo "  --config     Validate AES67 config file"
        echo "  --legacy     Verify legacy cleanup"
        exit 0
        ;;
    *)
        echo "Unknown option: $1"
        echo "Run '$0 --help' for usage"
        exit 1
        ;;
esac

summary
