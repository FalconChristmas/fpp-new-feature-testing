"""
FPP AES67 Common — shared constants and config generation for AES67.

Single source of truth for all AES67 configuration values.
Used by:
  - apply_aes67_config  (generates PipeWire/PTP configs and restarts services)
  - fpp_aes67_sap       (SAP/SDP announcer)
"""

import json
import re

# ──────────────────────────────────────────────────────────────────────────────
# Paths
# ──────────────────────────────────────────────────────────────────────────────
FPP_MEDIA_DIR = "/home/fpp/media"
CONFIG_JSON_PATH = FPP_MEDIA_DIR + "/config/pipewire-aes67-instances.json"
RTP_CONF_PATH = "/etc/pipewire/pipewire.conf.d/96-fpp-aes67-rtp.conf"
SAP_CONF_PATH = "/etc/pipewire/pipewire.conf.d/96-fpp-aes67-sap.conf"
PTP_CONF_PATH = "/etc/ptp4l-fpp.conf"
PTP_LOG_PATH = "/var/log/ptp4l-fpp.log"
SAP_LOG_PATH = "/var/log/fpp_aes67_sap.log"

# ──────────────────────────────────────────────────────────────────────────────
# AES67 Protocol Constants
# ──────────────────────────────────────────────────────────────────────────────
RTP_PAYLOAD_TYPE = 96           # Dynamic payload type for L24
AUDIO_FORMAT = "S24BE"          # 24-bit big-endian (AES67 L24)
AUDIO_RATE = 48000              # 48 kHz sample rate
AUDIO_RTP_TTL = 4               # TTL for RTP multicast packets
DEFAULT_PTIME = 4               # Default packet time in ms
VALID_PTIMES = (1, 4)           # AES67 allows only 1ms or 4ms

# SAP announcement constants
SAP_MCAST_ADDRESS = "239.255.255.255"  # AES67 administratively-scoped SAP
SAP_PORT = 9875
SAP_VERSION = 1                 # SAPv2 (version field = 1)
SAP_ANNOUNCE_INTERVAL = 30      # Seconds between SAP announcements
SAP_TTL = 255                   # TTL for SAP multicast packets

# ──────────────────────────────────────────────────────────────────────────────
# Instance Defaults
# ──────────────────────────────────────────────────────────────────────────────
DEFAULT_MULTICAST_IP = "239.69.0.1"
DEFAULT_PORT = 5004
DEFAULT_CHANNELS = 2
DEFAULT_LATENCY = 10
DEFAULT_MODE = "send"

# ──────────────────────────────────────────────────────────────────────────────
# Channel Position Maps (PipeWire format and SDP format)
# ──────────────────────────────────────────────────────────────────────────────
CHANNEL_POSITIONS_PW = {
    1: "[ MONO ]",
    2: "[ FL FR ]",
    4: "[ FL FR RL RR ]",
    6: "[ FL FR FC LFE RL RR ]",
    8: "[ FL FR FC LFE RL RR SL SR ]",
}

CHANNEL_POSITIONS_SDP = {
    1: "M",
    2: "FL, FR",
    4: "FL, FR, RL, RR",
    6: "FL, FR, FC, LFE, RL, RR",
    8: "FL, FR, FC, LFE, RL, RR, SL, SR",
}


# ──────────────────────────────────────────────────────────────────────────────
# Helpers
# ──────────────────────────────────────────────────────────────────────────────

def validate_ptime(ptime):
    """Validate and return a valid AES67 ptime value."""
    try:
        ptime = int(ptime)
    except (TypeError, ValueError):
        return DEFAULT_PTIME
    return ptime if ptime in VALID_PTIMES else DEFAULT_PTIME


def safe_node_name(name):
    """Convert instance name to a PipeWire-safe node name."""
    result = "aes67_"
    for c in name:
        if c.isalnum() or c == '_':
            result += c.lower()
        else:
            result += '_'
    return result


def get_pw_channel_position(channels):
    """Get PipeWire channel position array string."""
    return CHANNEL_POSITIONS_PW.get(channels, CHANNEL_POSITIONS_PW[2])


def get_sdp_channel_names(channels):
    """Get SDP channel name string."""
    if channels in CHANNEL_POSITIONS_SDP:
        return CHANNEL_POSITIONS_SDP[channels]
    return ", ".join(f"AUX{i+1}" for i in range(channels))


def load_config(path=None):
    """Load AES67 instance configuration from JSON."""
    if path is None:
        path = CONFIG_JSON_PATH
    try:
        with open(path, "r") as f:
            return json.load(f)
    except Exception:
        return None


# ──────────────────────────────────────────────────────────────────────────────
# PipeWire Config Generation
# ──────────────────────────────────────────────────────────────────────────────

def generate_rtp_config(instances):
    """
    Generate PipeWire RTP module config for all enabled AES67 instances.
    Returns the config file content as a string.
    """
    lines = [
        "# Auto-generated by FPP – AES67 multi-instance RTP configuration",
        "context.modules = [",
    ]

    for inst in instances:
        if not inst.get("enabled", True):
            continue

        name = inst.get("name", "AES67")
        node_name = safe_node_name(name)
        mode = inst.get("mode", DEFAULT_MODE)
        ip = inst.get("multicastIP", DEFAULT_MULTICAST_IP)
        port = inst.get("port", DEFAULT_PORT)
        channels = inst.get("channels", DEFAULT_CHANNELS)
        session_name = inst.get("sessionName", name)
        latency = inst.get("latency", DEFAULT_LATENCY)
        iface = inst.get("interface", "")
        audio_pos = get_pw_channel_position(channels)
        ptime = validate_ptime(inst.get("ptime", DEFAULT_PTIME))

        want_send = mode in ("send", "both")
        want_recv = mode in ("receive", "both")

        if want_send:
            lines.append("  { name = libpipewire-module-rtp-sink")
            lines.append("    args = {")
            if iface:
                lines.append(f'      local.ifname = "{iface}"')
            lines.append(f'      destination.ip = "{ip}"')
            lines.append(f"      destination.port = {port}")
            lines.append(f"      net.ttl = {AUDIO_RTP_TTL}")
            lines.append(f'      sess.name = "{session_name}"')
            lines.append(f"      sess.min-ptime = {ptime}")
            lines.append(f"      sess.max-ptime = {ptime}")
            lines.append(f'      audio.format = "{AUDIO_FORMAT}"')
            lines.append(f"      audio.rate = {AUDIO_RATE}")
            lines.append(f"      audio.channels = {channels}")
            lines.append(f"      audio.position = {audio_pos}")
            lines.append("      stream.props = {")
            lines.append(f"        rtp.payload = {RTP_PAYLOAD_TYPE}")
            lines.append(f'        node.name = "{node_name}_send"')
            lines.append(f'        node.description = "{session_name} (Send)"')
            lines.append('        media.class = "Audio/Sink"')
            lines.append("      }")
            lines.append("    }")
            lines.append("  }")

        if want_recv:
            lines.append("  { name = libpipewire-module-rtp-source")
            lines.append("    args = {")
            if iface:
                lines.append(f'      local.ifname = "{iface}"')
            lines.append(f'      source.ip = "{ip}"')
            lines.append(f"      source.port = {port}")
            lines.append(f"      sess.latency.msec = {latency}")
            lines.append(f'      audio.format = "{AUDIO_FORMAT}"')
            lines.append(f"      audio.rate = {AUDIO_RATE}")
            lines.append(f"      audio.channels = {channels}")
            lines.append(f"      audio.position = {audio_pos}")
            lines.append("      stream.props = {")
            lines.append(f'        node.name = "{node_name}_recv"')
            lines.append(f'        node.description = "{session_name} (Receive)"')
            lines.append('        media.class = "Audio/Source"')
            lines.append("      }")
            lines.append("    }")
            lines.append("  }")

    lines.append("]")
    return "\n".join(lines) + "\n"


def generate_sap_config(instances, default_iface=""):
    """
    Generate PipeWire SAP module config (receive-only).
    Outbound SAP is handled by fpp_aes67_sap.
    Returns config string, or empty string if no SAP needed.
    """
    any_sap = False
    latency = DEFAULT_LATENCY
    iface = default_iface

    for inst in instances:
        if not inst.get("enabled", True):
            continue
        if inst.get("sapEnabled", True):
            any_sap = True
            latency = inst.get("latency", DEFAULT_LATENCY)
            if inst.get("interface", ""):
                iface = inst["interface"]

    if not any_sap:
        return ""

    lines = [
        "# Auto-generated by FPP – AES67 SAP receive-only configuration",
        "# Outbound SAP announcements handled by fpp_aes67_sap daemon",
        "context.modules = [",
        "  { name = libpipewire-module-rtp-sap",
        "    args = {",
    ]
    if iface:
        lines.append(f'      local.ifname = "{iface}"')
    lines.append(f'      sap.ip = "{SAP_MCAST_ADDRESS}"')
    lines.append(f"      sap.port = {SAP_PORT}")
    lines.append(f"      net.ttl = {SAP_TTL}")
    lines.append("      stream.rules = [")
    lines.append("        { matches = [")
    lines.append('            { rtp.session = "~.*" }')
    lines.append("          ]")
    lines.append("          actions = {")
    lines.append("            create-stream = {")
    lines.append(f"              sess.latency.msec = {latency}")
    lines.append("            }")
    lines.append("          }")
    lines.append("        }")
    lines.append("      ]")
    lines.append("    }")
    lines.append("  }")
    lines.append("]")
    return "\n".join(lines) + "\n"


def generate_ptp_config():
    """Generate PTP config for AES67 grandmaster operation.

    FPP participates in PTP BMCA (Best Master Clock Algorithm) so it can
    act as grandmaster when no dedicated PTP master is on the network.

    Clock quality parameters are set to values that strict AES67 receivers
    (e.g. AES67 Stream Monitor) will accept:
      - clockClass 128: "designated GM, has been/can be synced" (vs 248 = free-running junk)
      - clockAccuracy 0x22: within 250ns (Pi hardware timestamping with ptp0 is typically <1μs)
      - offsetScaledLogVariance 0x4E5D: standard value for a good local oscillator
      - priority1/priority2 128: default, so a dedicated GM with better priority wins BMCA

    If a real GPS-disciplined GM is added to the network, it will naturally
    take over via BMCA due to better clockClass/accuracy.
    """
    return (
        "# Auto-generated by FPP – PTP config for AES67\n"
        "[global]\n"
        "domainNumber 0\n"
        "logging_level 6\n"
        "priority1 128\n"
        "priority2 128\n"
        "clockClass 128\n"
        "clockAccuracy 0x22\n"
        "offsetScaledLogVariance 0x4E5D\n"
        "clock_servo linreg\n"
        "network_transport UDPv4\n"
        "time_stamping hardware\n"
    )


def build_sdp(instance, source_ip, ptp_clock_id):
    """Build an AES67-compliant SDP for a send instance."""
    session_id = str(abs(hash(instance["name"])) % 2**31)
    channels = instance.get("channels", DEFAULT_CHANNELS)
    multicast_ip = instance.get("multicastIP", DEFAULT_MULTICAST_IP)
    port = instance.get("port", DEFAULT_PORT)
    session_name = instance.get("sessionName", instance.get("name", "FPP AES67"))
    ptime = str(validate_ptime(instance.get("ptime", DEFAULT_PTIME)))
    ch_names = get_sdp_channel_names(channels)

    sdp = (
        f"v=0\r\n"
        f"o=- {session_id} {session_id} IN IP4 {source_ip}\r\n"
        f"s={session_name}\r\n"
        f"c=IN IP4 {multicast_ip}/{SAP_TTL}\r\n"
        f"t=0 0\r\n"
        f"m=audio {port} RTP/AVP {RTP_PAYLOAD_TYPE}\r\n"
        f"a=rtpmap:{RTP_PAYLOAD_TYPE} L24/{AUDIO_RATE}/{channels}\r\n"
        f"a=sendonly\r\n"
        f"a=ptime:{ptime}\r\n"
        f"a=ts-refclk:ptp=IEEE1588-2008:{ptp_clock_id}:0\r\n"
        f"a=mediaclk:direct=0\r\n"
    )
    return sdp
